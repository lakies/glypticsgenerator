//-----------------------------------------------------
//Copyright (C) 2008 Mat�as N. Goldberg (Dark Sylinc)
//
//SSS (Sub-surface Scattering) fake
//
//Hardware Requierements:
// Vertex Shader 1.1
// Pixel Shader 3.0
// A video card capable of using PF_FLOAT32_R textures (32-bit float)
//
//Special thanks to:
//	*NVIDIA, for it's whitepaper about Volume Fog where I got
//	 how to compute thickness:
//   http://developer.download.nvidia.com/SDK/9.5/Samples/DEMOS/Direct3D9/src/FogPolygonVolumes3/docs/FogPolygonVolumes3.pdf
//	 and inspiring me to do this shader
//	*Wikipedia, for explaining me what SSS is.
// (Note the author has no relation nor is he affiliated in any way to
//	the companies/brands named above)
//  *If you feel you should be here, email me: dark_sylinc at yahoo dot com dot ar
//
//This shader is a fake, it doesn't emulate the physics of true SSS
//but is good enough for the human eye (in my opinion...)
//
//The algorithm needs 5 passes, but renders the scene 3 times:
//	1) Render the scene
//	2) Render Back faces saving depth info only
//	3) Render Front faces saving depth info only
//	4) Compute Thickness = Front - Back
//	5) Mix the result with the actual scene through a PS
//
//**************************
//How to use
//**************************
//In order to work you have to:
//	 All objects in the scene need to have applied a material template
//	 You create your material this way:
//	 material MyMaterial/MyMat : Ogre/SSS/SSS_Template
//	 Then activate the Compositor "SSS Fake"
//
//Parameters (can be customized per material):
//	ThicknessScale: Values higher than 1 will increase the thickness
//					thus making the SSS effect more visible,
//					Values between 0 & 1 reduce thickness
//	Offset: Sometimes surfaces are not thick enough or too thick.
//			Big values will make it more opaque, but also brighten. Compensate with lower luminance
//			Small (& Negative) values will make very transparent objects, and also darken. Compensate w/ more luminance
//	Luminance: Increase it to get an overall luminance increase
//			   Values 0...1  will decrease luminance
//
//GOING TOO SLOW???
//	Try changing the resolution of the SSS textures to a fixed one.
//	Go to Examples.compositor, find "compositor SSS Fake" and change lines:
//      texture rt_backFaces target_width target_height PF_FLOAT32_R
//      texture rt_frontFaces target_width target_height PF_FLOAT32_R
//      texture rt_SSSInfo target_width target_height PF_FLOAT32_R
//  Change target_width & target_height with reasonable values like 512
//
//Known issues: (dd/mm/yy)
//	02/04/08: OpenGL is half slow as Direct3D. Pherhaps wrong profiles?
//-----------------------------------------------------

//Vertex Program
//We only compute the positions, which is what we're only interested
//Then we save the depth. We should actually compute the distance
//from the viewpoint to the pixel. But I think this is enough.
void main_vp(float4 position	: POSITION,
			 // outputs
			 out float4 oPosition    : POSITION,
			 //out float  oUV			 : TEXCOORD0,
			 out float  depth		 : TEXCOORD0,
			 uniform float4x4 worldViewProj)
{
	//Transform position
	oPosition = mul(worldViewProj, position);
	
	//Save the Z-depth
	depth = oPosition.z;
}

//Pixel/Fragment shader
//Save the depth to a texture in the first component.
//Preffered is a 32-bit texture like PF_FLOAT32_R
float main_fp( float depth : TEXCOORD0 ) : COLOR
{
	return depth;
}

//Pixel/Fragment shader
//Computes Front Minus Back from two textures (thickness)
float mainFmB_fp( float2 uv : TEXCOORD0,
				   uniform sampler Front : register(s0),
				   uniform sampler Back : register(s1) ) : COLOR
{
	float front = tex2D( Front, uv );
	float back = tex2D( Back, uv );
	
	if ((front == 0 || back == 0) && !(front == 0 && back == 0)) {
		return 100000000000.0;
	}

	return front - back;
}

//Shows only the formula using the thickness
float4 mainDebugBlendSSS_fp( float2 uv : TEXCOORD0,
					    uniform sampler SSS : register(s0),
					    uniform float ThicknessScale,
					    uniform float Offset,
					    uniform float Luminance ) : COLOR
{
	float S = tex2D( SSS, uv );
	float4 colour = (sqrt( ThicknessScale / S) + Offset) * Luminance;

	// if(S > 10000000){
	// 	colour = float4(1, 0, 0, 1);
	// }


	return colour;
}

//Blend the thickness with the final scene
float4 mainBlendSSS_fp( float2 uv : TEXCOORD0,
					    uniform sampler Scene : register(s0),
					    uniform sampler SSS : register(s1),
					    uniform float ThicknessScale,
					    uniform float Offset,
					    uniform float Luminance ) : COLOR
{
	float S = tex2D( SSS, uv );
	float4 colour = tex2D( Scene, uv ) * 0.3 + tex2D( Scene, uv ) * 0.7 * (sqrt( ThicknessScale / S) + Offset) * Luminance;
	//float4 colour;
	//float factor = (sqrt( ThicknessScale / S) + Offset) * Luminance;
	//colour = factor;
	return colour;
}
